/* global.js
   Posicionamento absoluto + JS que empilha os botões acima do menu.
   Funciona independentemente da quantidade de botões dentro de .mobile-nav-buttons.
*/

(function () {
  const MOBILE_MAX = 768;

  const isMobile = () => window.matchMedia && window.matchMedia(`(max-width: ${MOBILE_MAX}px)`).matches;

  document.addEventListener('DOMContentLoaded', () => {
    const container = document.querySelector('.mobile-nav-buttons');
    if (!container) return;

    // ARIA
    container.setAttribute('role', 'navigation');
    container.setAttribute('aria-label', 'Navegação móvel');

    // Cria #mobile-menu-btn se necessário
    let menuBtn = document.getElementById('mobile-menu-btn');
    if (!menuBtn) {
      menuBtn = document.createElement('button');
      menuBtn.id = 'mobile-menu-btn';
      menuBtn.className = 'mobile-nav-btn';
      menuBtn.type = 'button';
      menuBtn.title = 'Abrir menu';
      menuBtn.setAttribute('aria-label', 'Abrir menu');
      menuBtn.setAttribute('aria-expanded', 'false');
      menuBtn.setAttribute('aria-haspopup', 'true');
      menuBtn.style.touchAction = 'manipulation';
      // garante que fique na base (bottom/right)
      menuBtn.style.bottom = '0';
      menuBtn.style.right = '0';
      menuBtn.style.position = 'absolute';
      menuBtn.style.pointerEvents = 'auto';
      // ícone
      const icon = document.createElement('i');
      icon.className = 'fas fa-bars';
      icon.setAttribute('aria-hidden', 'true');
      menuBtn.appendChild(icon);
      container.appendChild(menuBtn);
    } else {
      // garanto position absoluto caso CSS externo interfira
      menuBtn.style.position = 'absolute';
      menuBtn.style.bottom = '0';
      menuBtn.style.right = '0';
      menuBtn.style.pointerEvents = 'auto';
      menuBtn.setAttribute('aria-expanded', menuBtn.getAttribute('aria-expanded') || 'false');
    }

    // Pegar todos os botões (live NodeList)
    const getNavButtons = () => Array.from(container.querySelectorAll('.mobile-nav-btn'));

    // lê variáveis CSS (fallbacks)
    const readNumberVar = (el, name, fallback) => {
      const val = getComputedStyle(el).getPropertyValue(name).trim();
      if (!val) return fallback;
      const parsed = parseFloat(val);
      return isNaN(parsed) ? fallback : parsed;
    };

    // função que aplica posições quando open=true/false
    let animating = false;
    const applyPositions = (open) => {
      const btns = getNavButtons();
      // separa menuBtn e demais (preserva DOM order)
      const others = btns.filter(b => b.id !== 'mobile-menu-btn');
      // pega tamanho e gap a partir do container/roots
      const size = readNumberVar(container, '--mobile-nav-size', 60);
      const gap = readNumberVar(container, '--mobile-nav-gap', 12);
      const step = Math.round(size + gap);

      // base z
      const baseZ = readNumberVar(container, '--mobile-nav-z', 1200);

      // menuBtn (fica na base)
      menuBtn.style.transform = 'translateY(0) scale(1)';
      menuBtn.style.opacity = '1';
      menuBtn.style.visibility = 'visible';
      menuBtn.style.zIndex = String(baseZ + 40);
      menuBtn.style.pointerEvents = 'auto';

      if (!open) {
        // recolher: posiciona todos no mesmo lugar (embaixo), invisíveis
        others.forEach((btn) => {
          btn.style.transform = 'translateY(0) scale(.98)';
          btn.style.opacity = '0';
          btn.style.visibility = 'hidden';
          btn.style.pointerEvents = 'none';
          btn.style.zIndex = String(baseZ + 50); // continuará acima do menu quando expandidos
        });
        container.classList.remove('open');
        menuBtn.setAttribute('aria-expanded', 'false');
        return;
      }

      // abrir: para cada botão i, mover para cima por (i+1)*step px
      others.forEach((btn, i) => {
        const offset = (i + 1) * step;
        // mover para cima: negativo no translateY
        btn.style.transform = `translateY(-${offset}px) scale(1)`;
        btn.style.opacity = '1';
        btn.style.visibility = 'visible';
        btn.style.pointerEvents = 'auto';
        // zIndex: quem fica mais acima (maior offset) deve ter maior z-index
        btn.style.zIndex = String(baseZ + 60 + (others.length - i));
      });

      container.classList.add('open');
      menuBtn.setAttribute('aria-expanded', 'true');
    };

    // toggle
    const toggle = () => {
      if (!isMobile()) {
        applyPositions(false);
        return;
      }
      if (animating) return;
      animating = true;
      const open = !container.classList.contains('open');
      applyPositions(open);
      setTimeout(() => { animating = false; }, 360);
    };

    // clique no menu
    menuBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      toggle();
    });

    // clique em qualquer outro botão fecha depois de pequeno delay (permite ação do botão)
    container.addEventListener('click', (e) => {
      const target = e.target.closest('.mobile-nav-btn, .mobile-signout');
      if (!target) return;
      if (target.id === 'mobile-menu-btn') return;
      // deixa o botão executar e então fecha
      setTimeout(() => applyPositions(false), 120);
    });

    // fechamento ao clicar fora
    document.addEventListener('click', (e) => {
      if (!container.classList.contains('open')) return;
      if (e.target.closest && e.target.closest('.mobile-nav-buttons')) return;
      applyPositions(false);
    });

    // ESC fecha
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && container.classList.contains('open')) {
        applyPositions(false);
      }
    });

    // Reajusta ao redimensionar (fecha se sair do mobile)
    let resizeTimer = null;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => {
        if (!isMobile()) applyPositions(false);
        else {
          // reaplica posições caso já esteja aberto
          if (container.classList.contains('open')) applyPositions(true);
        }
      }, 120);
    });

    // Inicial: garante posição recolhida
    applyPositions(false);
  });
})();

/* ========= GLOBAL ALERT MODAL (override window.alert) ========= */
(function () {
  if (window.__customAlertInstalled) return;
  window.__customAlertInstalled = true;

  const createAlertModal = (message) => {
    const backdrop = document.createElement('div');
    backdrop.className = 'alert-backdrop';

    const modal = document.createElement('div');
    modal.className = 'alert-modal';
    modal.setAttribute('role', 'alertdialog');
    modal.setAttribute('aria-modal', 'true');

    modal.innerHTML = `
      <div class="alert-header">Aviso</div>
      <div class="alert-body">${message}</div>
      <div class="alert-actions">
        <button class="alert-btn">OK</button>
      </div>
    `;

    backdrop.appendChild(modal);
    document.body.appendChild(backdrop);

    requestAnimationFrame(() => backdrop.classList.add('visible'));

    const close = () => {
      backdrop.classList.remove('visible');
      setTimeout(() => backdrop.remove(), 300);
    };

    backdrop.addEventListener('click', (e) => {
      if (e.target === backdrop) close();
    });

    modal.querySelector('.alert-btn').addEventListener('click', close);

    document.addEventListener(
      'keydown',
      function esc(e) {
        if (e.key === 'Escape') {
          close();
          document.removeEventListener('keydown', esc);
        }
      },
      { once: true }
    );
  };

  window.alert = function (msg) {
    createAlertModal(String(msg));
  };
  
})();

/* ===== global: adapta cor do texto das condições conforme background =====
   Auto-aplica a elementos .cond-pill e .cond-badge quando criarem/alterarem cor.
   Cole no final de global.js.
*/
(function () {
  'use strict';

  // converte "rgb(255, 0, 0)" ou "rgba(255,0,0,0.7)" em {r,g,b}
  function rgbStringToRgb(str) {
    const m = str.match(/rgba?\s*\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})/i);
    if (!m) return null;
    return { r: +m[1], g: +m[2], b: +m[3] };
  }

  // converte "#abc" ou "#aabbcc" para rgb
  function hexToRgb(hex) {
    if (!hex) return null;
    hex = hex.replace(/\s+/g, '');
    const short = /^#?([0-9a-f]{3})$/i;
    const full = /^#?([0-9a-f]{6})$/i;
    let m;
    if ((m = hex.match(full))) {
      const v = m[1];
      return {
        r: parseInt(v.slice(0,2),16),
        g: parseInt(v.slice(2,4),16),
        b: parseInt(v.slice(4,6),16)
      };
    } else if ((m = hex.match(short))) {
      const v = m[1];
      return {
        r: parseInt(v[0]+v[0],16),
        g: parseInt(v[1]+v[1],16),
        b: parseInt(v[2]+v[2],16)
      };
    }
    return null;
  }

  // calcula luminância relativa (0 = preto, 1 = branco) baseado nas componentes sRGB
  function relativeLuminance(rgb) {
    if (!rgb) return 0;
    const srgb = [rgb.r/255, rgb.g/255, rgb.b/255].map(c => {
      return (c <= 0.03928) ? (c/12.92) : Math.pow((c+0.055)/1.055, 2.4);
    });
    return 0.2126 * srgb[0] + 0.7152 * srgb[1] + 0.0722 * srgb[2];
  }

  // tenta extrair um color token (hex or rgb) a partir do estilo inline ou computed style.
  function extractEffectiveColor(el) {
    if (!el) return null;
    // 1) checar style inline primeiro (ex: style="background: #aabbcc" ou "background: linear-gradient(..., #aabbcc, ...)")
    const inline = el.getAttribute && el.getAttribute('style');
    if (inline) {
      // procura por hex
      const hexMatch = inline.match(/#([0-9a-f]{3}|[0-9a-f]{6})/i);
      if (hexMatch) return '#' + hexMatch[1];
      // procura por rgb(...)
      const rgbMatch = inline.match(/rgba?\([^\)]+\)/i);
      if (rgbMatch) return rgbMatch[0];
      // se style.backgroundColor existir no style object
      try {
        if (el.style && el.style.backgroundColor) {
          return el.style.backgroundColor;
        }
      } catch(e) {}
    }

    // 2) computed style (retorna algo como "rgb(10, 20, 30)" ou "transparent")
    const cs = getComputedStyle(el);
    if (cs) {
      // tenta background-color
      const bc = cs.getPropertyValue('background-color');
      if (bc && bc !== 'transparent' && bc !== 'rgba(0, 0, 0, 0)') return bc;
      // se for gradiente, computed background-color pode ser transparent; tentamos extrair a primeira cor do background-image
      const bgImage = cs.getPropertyValue('background-image') || '';
      const hexMatch2 = bgImage.match(/#([0-9a-f]{3}|[0-9a-f]{6})/i);
      if (hexMatch2) return '#' + hexMatch2[1];
      const rgbMatch2 = bgImage.match(/rgba?\([^\)]+\)/i);
      if (rgbMatch2) return rgbMatch2[0];
    }

    return null;
  }

  // decide se cor é "escura"
  function isDarkColor(rgb) {
    if (!rgb) return true; // fallback considera escuro
    const lum = relativeLuminance(rgb);
    // threshold: 0.5 (ajustável). Valores menores => mais escuro.
    return lum < 0.5;
  }

  // aplica classes cond-text-light / cond-text-dark ao elemento (remove a oposta)
  function applyContrastClass(el, useLight) {
    if (!el || !el.classList) return;
    if (useLight) {
      el.classList.add('cond-text-light');
      el.classList.remove('cond-text-dark');
    } else {
      el.classList.add('cond-text-dark');
      el.classList.remove('cond-text-light');
    }
  }

  // atualizar um único elemento (.cond-pill ou .cond-badge)
  function updateContrastForElement(el) {
    if (!el) return;
    const raw = extractEffectiveColor(el);
    let rgb = null;

    if (!raw) {
      // nada encontrado — tenta herdar do parent
      const parent = el.parentElement;
      if (parent) {
        const parentRaw = extractEffectiveColor(parent);
        if (parentRaw) {
          if (parentRaw.startsWith('#')) rgb = hexToRgb(parentRaw);
          else rgb = rgbStringToRgb(parentRaw);
        }
      }
    } else {
      if (raw.startsWith('#')) rgb = hexToRgb(raw);
      else if (raw.toLowerCase().startsWith('rgb')) rgb = rgbStringToRgb(raw);
      else {
        // tenta capturar hex dentro da string
        const m = raw.match(/#([0-9a-f]{3}|[0-9a-f]{6})/i);
        if (m) rgb = hexToRgb('#'+m[1]);
      }
    }

    const dark = isDarkColor(rgb);
    applyContrastClass(el, dark); // se escuro => texto claro (useLight = true)
  }

  // varredura e atualização para todos os elementos alvo
  function updateConditionTextContrast() {
    try {
      const list = Array.from(document.querySelectorAll('.cond-pill, .cond-badge'));
      list.forEach(el => updateContrastForElement(el));
    } catch (e) {
      console.warn('updateConditionTextContrast erro', e);
    }
  }

  // Small optimization: only process nodes that match selectors
  const MATCH_SELECTORS = '.cond-pill, .cond-badge';

  // MutationObserver que observa adições e mudanças de atributo "style" / "class"
  const mo = new MutationObserver((mutations) => {
    const toHandle = new Set();
    for (const m of mutations) {
      if (m.type === 'childList') {
        m.addedNodes.forEach(n => {
          if (!(n instanceof Element)) return;
          if (n.matches && n.matches(MATCH_SELECTORS)) toHandle.add(n);
          // also check descendants
          const inner = n.querySelectorAll && Array.from(n.querySelectorAll(MATCH_SELECTORS));
          if (inner && inner.length) inner.forEach(i => toHandle.add(i));
        });
      } else if (m.type === 'attributes' && (m.attributeName === 'style' || m.attributeName === 'class')) {
        const t = m.target;
        if (t && t.matches && t.matches(MATCH_SELECTORS)) toHandle.add(t);
      }
    }
    if (toHandle.size) {
      toHandle.forEach(el => {
        try { updateContrastForElement(el); } catch (e) { /* silent */ }
      });
    }
  });

  function startObserver() {
    try {
      mo.observe(document.documentElement, { childList: true, subtree: true, attributes: true, attributeFilter: ['style','class'] });
    } catch (e) {
      console.warn('Observer failed to start', e);
    }
  }

  // inicial: rodar no DOMContentLoaded/ready e iniciar observer
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      updateConditionTextContrast();
      startObserver();
    });
  } else {
    updateConditionTextContrast();
    startObserver();
  }

  // expor função globalmente para casos em que você queira forçar a atualização manualmente
  window.updateConditionTextContrast = updateConditionTextContrast;

})();
